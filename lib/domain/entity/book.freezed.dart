// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'book.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Book {
  String get path => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  String? get imageUrl => throw _privateConstructorUsedError;
  String? get author => throw _privateConstructorUsedError;
  String? get publisher => throw _privateConstructorUsedError;
  String? get location => throw _privateConstructorUsedError;
  String? get callMark => throw _privateConstructorUsedError;
  String? get material => throw _privateConstructorUsedError;
  String? get publication => throw _privateConstructorUsedError;
  String? get form => throw _privateConstructorUsedError;
  String? get alternative => throw _privateConstructorUsedError;
  String? get countryOfPublication => throw _privateConstructorUsedError;
  String? get titleLanguage => throw _privateConstructorUsedError;
  String? get languageOfTexts => throw _privateConstructorUsedError;
  String? get languageOfOriginal => throw _privateConstructorUsedError;
  String? get isbn => throw _privateConstructorUsedError;
  String? get ncid => throw _privateConstructorUsedError;

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BookCopyWith<Book> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookCopyWith<$Res> {
  factory $BookCopyWith(Book value, $Res Function(Book) then) =
      _$BookCopyWithImpl<$Res, Book>;
  @useResult
  $Res call(
      {String path,
      String? title,
      String? imageUrl,
      String? author,
      String? publisher,
      String? location,
      String? callMark,
      String? material,
      String? publication,
      String? form,
      String? alternative,
      String? countryOfPublication,
      String? titleLanguage,
      String? languageOfTexts,
      String? languageOfOriginal,
      String? isbn,
      String? ncid});
}

/// @nodoc
class _$BookCopyWithImpl<$Res, $Val extends Book>
    implements $BookCopyWith<$Res> {
  _$BookCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? title = freezed,
    Object? imageUrl = freezed,
    Object? author = freezed,
    Object? publisher = freezed,
    Object? location = freezed,
    Object? callMark = freezed,
    Object? material = freezed,
    Object? publication = freezed,
    Object? form = freezed,
    Object? alternative = freezed,
    Object? countryOfPublication = freezed,
    Object? titleLanguage = freezed,
    Object? languageOfTexts = freezed,
    Object? languageOfOriginal = freezed,
    Object? isbn = freezed,
    Object? ncid = freezed,
  }) {
    return _then(_value.copyWith(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      author: freezed == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as String?,
      publisher: freezed == publisher
          ? _value.publisher
          : publisher // ignore: cast_nullable_to_non_nullable
              as String?,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      callMark: freezed == callMark
          ? _value.callMark
          : callMark // ignore: cast_nullable_to_non_nullable
              as String?,
      material: freezed == material
          ? _value.material
          : material // ignore: cast_nullable_to_non_nullable
              as String?,
      publication: freezed == publication
          ? _value.publication
          : publication // ignore: cast_nullable_to_non_nullable
              as String?,
      form: freezed == form
          ? _value.form
          : form // ignore: cast_nullable_to_non_nullable
              as String?,
      alternative: freezed == alternative
          ? _value.alternative
          : alternative // ignore: cast_nullable_to_non_nullable
              as String?,
      countryOfPublication: freezed == countryOfPublication
          ? _value.countryOfPublication
          : countryOfPublication // ignore: cast_nullable_to_non_nullable
              as String?,
      titleLanguage: freezed == titleLanguage
          ? _value.titleLanguage
          : titleLanguage // ignore: cast_nullable_to_non_nullable
              as String?,
      languageOfTexts: freezed == languageOfTexts
          ? _value.languageOfTexts
          : languageOfTexts // ignore: cast_nullable_to_non_nullable
              as String?,
      languageOfOriginal: freezed == languageOfOriginal
          ? _value.languageOfOriginal
          : languageOfOriginal // ignore: cast_nullable_to_non_nullable
              as String?,
      isbn: freezed == isbn
          ? _value.isbn
          : isbn // ignore: cast_nullable_to_non_nullable
              as String?,
      ncid: freezed == ncid
          ? _value.ncid
          : ncid // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookImplCopyWith<$Res> implements $BookCopyWith<$Res> {
  factory _$$BookImplCopyWith(
          _$BookImpl value, $Res Function(_$BookImpl) then) =
      __$$BookImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String path,
      String? title,
      String? imageUrl,
      String? author,
      String? publisher,
      String? location,
      String? callMark,
      String? material,
      String? publication,
      String? form,
      String? alternative,
      String? countryOfPublication,
      String? titleLanguage,
      String? languageOfTexts,
      String? languageOfOriginal,
      String? isbn,
      String? ncid});
}

/// @nodoc
class __$$BookImplCopyWithImpl<$Res>
    extends _$BookCopyWithImpl<$Res, _$BookImpl>
    implements _$$BookImplCopyWith<$Res> {
  __$$BookImplCopyWithImpl(_$BookImpl _value, $Res Function(_$BookImpl) _then)
      : super(_value, _then);

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? title = freezed,
    Object? imageUrl = freezed,
    Object? author = freezed,
    Object? publisher = freezed,
    Object? location = freezed,
    Object? callMark = freezed,
    Object? material = freezed,
    Object? publication = freezed,
    Object? form = freezed,
    Object? alternative = freezed,
    Object? countryOfPublication = freezed,
    Object? titleLanguage = freezed,
    Object? languageOfTexts = freezed,
    Object? languageOfOriginal = freezed,
    Object? isbn = freezed,
    Object? ncid = freezed,
  }) {
    return _then(_$BookImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      title: freezed == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      imageUrl: freezed == imageUrl
          ? _value.imageUrl
          : imageUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      author: freezed == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as String?,
      publisher: freezed == publisher
          ? _value.publisher
          : publisher // ignore: cast_nullable_to_non_nullable
              as String?,
      location: freezed == location
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String?,
      callMark: freezed == callMark
          ? _value.callMark
          : callMark // ignore: cast_nullable_to_non_nullable
              as String?,
      material: freezed == material
          ? _value.material
          : material // ignore: cast_nullable_to_non_nullable
              as String?,
      publication: freezed == publication
          ? _value.publication
          : publication // ignore: cast_nullable_to_non_nullable
              as String?,
      form: freezed == form
          ? _value.form
          : form // ignore: cast_nullable_to_non_nullable
              as String?,
      alternative: freezed == alternative
          ? _value.alternative
          : alternative // ignore: cast_nullable_to_non_nullable
              as String?,
      countryOfPublication: freezed == countryOfPublication
          ? _value.countryOfPublication
          : countryOfPublication // ignore: cast_nullable_to_non_nullable
              as String?,
      titleLanguage: freezed == titleLanguage
          ? _value.titleLanguage
          : titleLanguage // ignore: cast_nullable_to_non_nullable
              as String?,
      languageOfTexts: freezed == languageOfTexts
          ? _value.languageOfTexts
          : languageOfTexts // ignore: cast_nullable_to_non_nullable
              as String?,
      languageOfOriginal: freezed == languageOfOriginal
          ? _value.languageOfOriginal
          : languageOfOriginal // ignore: cast_nullable_to_non_nullable
              as String?,
      isbn: freezed == isbn
          ? _value.isbn
          : isbn // ignore: cast_nullable_to_non_nullable
              as String?,
      ncid: freezed == ncid
          ? _value.ncid
          : ncid // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$BookImpl implements _Book {
  const _$BookImpl(
      {required this.path,
      this.title,
      this.imageUrl,
      this.author,
      this.publisher,
      this.location,
      this.callMark,
      this.material,
      this.publication,
      this.form,
      this.alternative,
      this.countryOfPublication,
      this.titleLanguage,
      this.languageOfTexts,
      this.languageOfOriginal,
      this.isbn,
      this.ncid});

  @override
  final String path;
  @override
  final String? title;
  @override
  final String? imageUrl;
  @override
  final String? author;
  @override
  final String? publisher;
  @override
  final String? location;
  @override
  final String? callMark;
  @override
  final String? material;
  @override
  final String? publication;
  @override
  final String? form;
  @override
  final String? alternative;
  @override
  final String? countryOfPublication;
  @override
  final String? titleLanguage;
  @override
  final String? languageOfTexts;
  @override
  final String? languageOfOriginal;
  @override
  final String? isbn;
  @override
  final String? ncid;

  @override
  String toString() {
    return 'Book(path: $path, title: $title, imageUrl: $imageUrl, author: $author, publisher: $publisher, location: $location, callMark: $callMark, material: $material, publication: $publication, form: $form, alternative: $alternative, countryOfPublication: $countryOfPublication, titleLanguage: $titleLanguage, languageOfTexts: $languageOfTexts, languageOfOriginal: $languageOfOriginal, isbn: $isbn, ncid: $ncid)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookImpl &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.imageUrl, imageUrl) ||
                other.imageUrl == imageUrl) &&
            (identical(other.author, author) || other.author == author) &&
            (identical(other.publisher, publisher) ||
                other.publisher == publisher) &&
            (identical(other.location, location) ||
                other.location == location) &&
            (identical(other.callMark, callMark) ||
                other.callMark == callMark) &&
            (identical(other.material, material) ||
                other.material == material) &&
            (identical(other.publication, publication) ||
                other.publication == publication) &&
            (identical(other.form, form) || other.form == form) &&
            (identical(other.alternative, alternative) ||
                other.alternative == alternative) &&
            (identical(other.countryOfPublication, countryOfPublication) ||
                other.countryOfPublication == countryOfPublication) &&
            (identical(other.titleLanguage, titleLanguage) ||
                other.titleLanguage == titleLanguage) &&
            (identical(other.languageOfTexts, languageOfTexts) ||
                other.languageOfTexts == languageOfTexts) &&
            (identical(other.languageOfOriginal, languageOfOriginal) ||
                other.languageOfOriginal == languageOfOriginal) &&
            (identical(other.isbn, isbn) || other.isbn == isbn) &&
            (identical(other.ncid, ncid) || other.ncid == ncid));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      path,
      title,
      imageUrl,
      author,
      publisher,
      location,
      callMark,
      material,
      publication,
      form,
      alternative,
      countryOfPublication,
      titleLanguage,
      languageOfTexts,
      languageOfOriginal,
      isbn,
      ncid);

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookImplCopyWith<_$BookImpl> get copyWith =>
      __$$BookImplCopyWithImpl<_$BookImpl>(this, _$identity);
}

abstract class _Book implements Book {
  const factory _Book(
      {required final String path,
      final String? title,
      final String? imageUrl,
      final String? author,
      final String? publisher,
      final String? location,
      final String? callMark,
      final String? material,
      final String? publication,
      final String? form,
      final String? alternative,
      final String? countryOfPublication,
      final String? titleLanguage,
      final String? languageOfTexts,
      final String? languageOfOriginal,
      final String? isbn,
      final String? ncid}) = _$BookImpl;

  @override
  String get path;
  @override
  String? get title;
  @override
  String? get imageUrl;
  @override
  String? get author;
  @override
  String? get publisher;
  @override
  String? get location;
  @override
  String? get callMark;
  @override
  String? get material;
  @override
  String? get publication;
  @override
  String? get form;
  @override
  String? get alternative;
  @override
  String? get countryOfPublication;
  @override
  String? get titleLanguage;
  @override
  String? get languageOfTexts;
  @override
  String? get languageOfOriginal;
  @override
  String? get isbn;
  @override
  String? get ncid;

  /// Create a copy of Book
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookImplCopyWith<_$BookImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BookSearchResult {
  List<Book> get books => throw _privateConstructorUsedError;
  bool get hasNext => throw _privateConstructorUsedError;

  /// Create a copy of BookSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BookSearchResultCopyWith<BookSearchResult> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookSearchResultCopyWith<$Res> {
  factory $BookSearchResultCopyWith(
          BookSearchResult value, $Res Function(BookSearchResult) then) =
      _$BookSearchResultCopyWithImpl<$Res, BookSearchResult>;
  @useResult
  $Res call({List<Book> books, bool hasNext});
}

/// @nodoc
class _$BookSearchResultCopyWithImpl<$Res, $Val extends BookSearchResult>
    implements $BookSearchResultCopyWith<$Res> {
  _$BookSearchResultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BookSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? books = null,
    Object? hasNext = null,
  }) {
    return _then(_value.copyWith(
      books: null == books
          ? _value.books
          : books // ignore: cast_nullable_to_non_nullable
              as List<Book>,
      hasNext: null == hasNext
          ? _value.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookSearchResultImplCopyWith<$Res>
    implements $BookSearchResultCopyWith<$Res> {
  factory _$$BookSearchResultImplCopyWith(_$BookSearchResultImpl value,
          $Res Function(_$BookSearchResultImpl) then) =
      __$$BookSearchResultImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<Book> books, bool hasNext});
}

/// @nodoc
class __$$BookSearchResultImplCopyWithImpl<$Res>
    extends _$BookSearchResultCopyWithImpl<$Res, _$BookSearchResultImpl>
    implements _$$BookSearchResultImplCopyWith<$Res> {
  __$$BookSearchResultImplCopyWithImpl(_$BookSearchResultImpl _value,
      $Res Function(_$BookSearchResultImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? books = null,
    Object? hasNext = null,
  }) {
    return _then(_$BookSearchResultImpl(
      books: null == books
          ? _value._books
          : books // ignore: cast_nullable_to_non_nullable
              as List<Book>,
      hasNext: null == hasNext
          ? _value.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$BookSearchResultImpl implements _BookSearchResult {
  const _$BookSearchResultImpl(
      {required final List<Book> books, required this.hasNext})
      : _books = books;

  final List<Book> _books;
  @override
  List<Book> get books {
    if (_books is EqualUnmodifiableListView) return _books;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_books);
  }

  @override
  final bool hasNext;

  @override
  String toString() {
    return 'BookSearchResult(books: $books, hasNext: $hasNext)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookSearchResultImpl &&
            const DeepCollectionEquality().equals(other._books, _books) &&
            (identical(other.hasNext, hasNext) || other.hasNext == hasNext));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_books), hasNext);

  /// Create a copy of BookSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookSearchResultImplCopyWith<_$BookSearchResultImpl> get copyWith =>
      __$$BookSearchResultImplCopyWithImpl<_$BookSearchResultImpl>(
          this, _$identity);
}

abstract class _BookSearchResult implements BookSearchResult {
  const factory _BookSearchResult(
      {required final List<Book> books,
      required final bool hasNext}) = _$BookSearchResultImpl;

  @override
  List<Book> get books;
  @override
  bool get hasNext;

  /// Create a copy of BookSearchResult
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookSearchResultImplCopyWith<_$BookSearchResultImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BookSearchQuery {
  String get query => throw _privateConstructorUsedError;
  BookSearchMode get mode => throw _privateConstructorUsedError;
  BookSearchOrder get order => throw _privateConstructorUsedError;
  int get start => throw _privateConstructorUsedError;
  int get count => throw _privateConstructorUsedError;

  /// Create a copy of BookSearchQuery
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $BookSearchQueryCopyWith<BookSearchQuery> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookSearchQueryCopyWith<$Res> {
  factory $BookSearchQueryCopyWith(
          BookSearchQuery value, $Res Function(BookSearchQuery) then) =
      _$BookSearchQueryCopyWithImpl<$Res, BookSearchQuery>;
  @useResult
  $Res call(
      {String query,
      BookSearchMode mode,
      BookSearchOrder order,
      int start,
      int count});
}

/// @nodoc
class _$BookSearchQueryCopyWithImpl<$Res, $Val extends BookSearchQuery>
    implements $BookSearchQueryCopyWith<$Res> {
  _$BookSearchQueryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BookSearchQuery
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? query = null,
    Object? mode = null,
    Object? order = null,
    Object? start = null,
    Object? count = null,
  }) {
    return _then(_value.copyWith(
      query: null == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as BookSearchMode,
      order: null == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as BookSearchOrder,
      start: null == start
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as int,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BookSearchQueryImplCopyWith<$Res>
    implements $BookSearchQueryCopyWith<$Res> {
  factory _$$BookSearchQueryImplCopyWith(_$BookSearchQueryImpl value,
          $Res Function(_$BookSearchQueryImpl) then) =
      __$$BookSearchQueryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String query,
      BookSearchMode mode,
      BookSearchOrder order,
      int start,
      int count});
}

/// @nodoc
class __$$BookSearchQueryImplCopyWithImpl<$Res>
    extends _$BookSearchQueryCopyWithImpl<$Res, _$BookSearchQueryImpl>
    implements _$$BookSearchQueryImplCopyWith<$Res> {
  __$$BookSearchQueryImplCopyWithImpl(
      _$BookSearchQueryImpl _value, $Res Function(_$BookSearchQueryImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookSearchQuery
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? query = null,
    Object? mode = null,
    Object? order = null,
    Object? start = null,
    Object? count = null,
  }) {
    return _then(_$BookSearchQueryImpl(
      query: null == query
          ? _value.query
          : query // ignore: cast_nullable_to_non_nullable
              as String,
      mode: null == mode
          ? _value.mode
          : mode // ignore: cast_nullable_to_non_nullable
              as BookSearchMode,
      order: null == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as BookSearchOrder,
      start: null == start
          ? _value.start
          : start // ignore: cast_nullable_to_non_nullable
              as int,
      count: null == count
          ? _value.count
          : count // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BookSearchQueryImpl implements _BookSearchQuery {
  const _$BookSearchQueryImpl(
      {required this.query,
      required this.mode,
      required this.order,
      required this.start,
      required this.count});

  @override
  final String query;
  @override
  final BookSearchMode mode;
  @override
  final BookSearchOrder order;
  @override
  final int start;
  @override
  final int count;

  @override
  String toString() {
    return 'BookSearchQuery(query: $query, mode: $mode, order: $order, start: $start, count: $count)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookSearchQueryImpl &&
            (identical(other.query, query) || other.query == query) &&
            (identical(other.mode, mode) || other.mode == mode) &&
            (identical(other.order, order) || other.order == order) &&
            (identical(other.start, start) || other.start == start) &&
            (identical(other.count, count) || other.count == count));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, query, mode, order, start, count);

  /// Create a copy of BookSearchQuery
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookSearchQueryImplCopyWith<_$BookSearchQueryImpl> get copyWith =>
      __$$BookSearchQueryImplCopyWithImpl<_$BookSearchQueryImpl>(
          this, _$identity);
}

abstract class _BookSearchQuery implements BookSearchQuery {
  const factory _BookSearchQuery(
      {required final String query,
      required final BookSearchMode mode,
      required final BookSearchOrder order,
      required final int start,
      required final int count}) = _$BookSearchQueryImpl;

  @override
  String get query;
  @override
  BookSearchMode get mode;
  @override
  BookSearchOrder get order;
  @override
  int get start;
  @override
  int get count;

  /// Create a copy of BookSearchQuery
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookSearchQueryImplCopyWith<_$BookSearchQueryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
